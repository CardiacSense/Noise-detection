function [flag,accMat,r2Acc,comp] = noiseFlag(PPG,fs,ACCX,ACCY,ACCZ)%,OQF)
%% Init
flag1 = zeros(size(PPG));
flag2 = zeros(size(PPG));
thr1 = 150;
r1thr = 0.99;
comp1thr = 0.77;
comp2thr = 1.2;
oqfThr = 0.8;
%% Detrend Acc Signals
Hp = hpAcc(fs,4,0.5);
ACCX = filter(Hp,ACCX);
ACCY = filter(Hp,ACCY);
ACCZ = filter(Hp,ACCZ);
%% Calc detrended Acc derivative R2 for a flatline fit
r2x = rsquared(gradient(ACCX),fs);
r2y = rsquared(gradient(ACCY),fs);
r2z = rsquared(gradient(ACCZ),fs);
% delay the signal to correlate  events
r2x = [r2x(2*fs:end); zeros(2*fs-1,1)];
r2y = [r2y(2*fs:end); zeros(2*fs-1,1)];
r2z = [r2z(2*fs:end); zeros(2*fs-1,1)];
%% Filter PPG
filtPPG = filterData(PPG,fs,5,10,0.5);
%% Flag Acc events
cnt = 1;
for k = fs/2+1:length(flag1)
    if (sum(abs(ACCX(k-fs/2:k))>thr1)>3 && sum(abs(ACCY(k-fs/2:k))>thr1)>3 &&sum(abs(ACCZ(k-fs/2:k))>thr1)>3 )||r2x(k)<r1thr || r2y(k)<r1thr || r2z(k)<r1thr
        flag1(k-fs/2:k) = 1;
        if k-fs/2-cnt <=2*fs
            flag1(cnt:k) = 1;
        end
    else
        cnt = k; %last known OK place
    end
    
end
flag = flag2 + flag1;
%% Calc complexity
%calc mobility and complexity
Num = movvar(gradient(filtPPG),fs);
Den = movvar(filtPPG,fs);
mob = sqrt(Num./Den);
Num2 = movvar(gradient(gradient(filtPPG)),64);
Den2 = Num;
mob2 = sqrt(Num2./Den2);
comp = sqrt(mob./mob2);
%% Flag "good" sig using oqf & complexity
compFlag = zeros(size(flag));
% oqfFlag = zeros(size(flag));
compFlag(comp>comp1thr & comp<comp2thr)= 1;
% oqfFlag(OQF>oqfThr) = 1;
% compOqfFlag = compFlag + oqfFlag;
compOqfFlag = compFlag;

counter = 0;
%% take Acc flag down when the signals "good" for 1/2 second
for k=1:length(flag)-1
    if  compOqfFlag(k)>1
        %start counting
        counter = counter+1;
    else
        %count how long is normal
        counter = 0;
        
    end
    if counter>fs/2
        flag(k-counter+1:k) = 0;
    end
end
%% outputs
%for debug
accMat = [ACCX(:),ACCY(:),ACCZ(:)];
r2Acc = [r2x(:),r2y(:),r2z(:)];

end
function Hd = hpAcc(Fs,N,Fc)
%HPACC Returns a discrete-time filter object.

% MATLAB Code
% Generated by MATLAB(R) 9.9 and Signal Processing Toolbox 8.5.
% Generated on: 04-Nov-2021 10:19:12

% Butterworth Highpass filter designed using FDESIGN.HIGHPASS.

% All frequency values are in Hz.


% Construct an FDESIGN object and call its BUTTER method.
h  = fdesign.highpass('N,F3dB', N, Fc, Fs);
Hd = design(h, 'butter');

% Get the transfer function values.
[b, a] = tf(Hd);

% Convert to a singleton filter.
Hd = dfilt.df2(b, a);



end
function r2 = rsquared(data,len)
SStot = movsum((data-movmean(data,[len 0])).^2,[len 0]);
SSres = movsum(movmean(data,[len 0]).^2,[len 0]);


r2 = 1 - SSres./SStot;

end
function filtered = filterData(sig,fs,lp,L,beta)
win = kaiser(L+1, beta);
% Calculate the coefficients using the FIR1 function.
b  = fir1(L, lp/(fs/2), 'low', win, 'scale');
Coeff = dfilt.dffir(b);
fSignal    =  -filter(Coeff,sig);
filtered = fSignal - movmean(fSignal,fs);
%% de-delay
filtered = [filtered(round(L/2)+1:end);nan(round(L/2),1)];
end